
---
layout: post
title: "250415 TIL"
subtitle: "C# 문법 종합반 3~4주차"
date: 2025-04-15
author: codingnewwbie
---

오늘 배운 내용 정리

## 객체지향프로그래밍의 특징
  1. 캡슐화 : 한 기능을 하나의 단위(클래스)로 묶어 정보 은닉 및 외부 접근 제한하여 안정성, 유지보수, 재사용성 증가.
  2. 상속 : 기존 클래스를 활용하여 새로운 클래스 생성. 부모 클래스 기능을 자식 클래스에서 사용 가능.
  3. 다형성 : 하나의 메소드 이름으로 다양한 객체에서 다르게 동작. 오버로딩과 오버라이딩
  4. 추상화 : 세부 구현은 미루고 복잡한 개념을 단순화하여 기능 구현에 집중
  5. 객체 : 클래스에서 생성되어 상태(데이터)와 행동(메서드)을 가지는 실체

## 클래스 구성요소
  1. 필드 : 멤버 변수
  2. 메서드 : 멤버 함수
  3. 생성자 : 생성될 때 자동 호출 / 디폴트 외 생성자 정의 시 디폴트 생성자 자동 생성 불가. 정의해줘야 함.
  4. 소멸자 : 소멸될 때 자동 호출
  5. 클래스 = 객체 생성하기 위한 틀, 객체 = 클래스에서 생성된 물체(혹은 물체들)

## 구조체 vs 클래스
  1. 모두 사용자 정의 형식
  2. 구조체: 값 형식, Stack 영역에 자동 할당 / 상속 불가능 / 작거나 단순한 구조
  3. 클래스: 참조 형식, Heap 영역에 자동 할당, 참조 전달 / 상속 가능 / 복잡한 구조

## 프로퍼티
  1. 객체 필드값들(private)를 외부에서 간접적으로 접근할 수 있는 중간다리
  2. get / set 별 접근제한이나 유효성 검사 가능.

## 상속
  1. C#에서 클래스는 클래스 다중상속 불가능. 인터페이스는 클래스 다중상속 가능

## 다형성
  1. 기본적으로 부모 클래스에서 정의되고 자식 클래스에서 (필요에 따라) 재정의
  2. 부모 클래스 참조 시 부모 메서드에 virtual 키워드가 있으면 자식이 해당 메서드를 override 했는지 확인. 했으면 자식 메서드 사용, 없으면 부모 메서드 사용.

## 추상클래스
  1. 직접 객체 생성 불가. 클래스나 메서드가 구현되어 있지 않음. 자식 클래스에서 구현함. abstract 키워드
  2. 부모 클래스 참조 시 자식의 override 메서드 참조함

## 오버라이딩 - 오버로딩
  1. 오버라이딩 : 이미 정의된 함수 재정의.
  2. 오버로딩 : 동일 이름의 함수를 매개변수(개수, 타입, 순서)에 따라 읽어올 때.

## 제너릭
  1. 해당 메서드에 다양한 자료형을 사용하고 싶을 때. <T> 키워드.
  2. 메서드 선언 시점이 아닌 사용 시점에 자료형 확정.
  3. 사용할 때는 T 말고 구체적 자료형 사용.

## out, ref 키워드
  1. 둘 다 메서드에서 매개변수 전달 시 사용.
  2. out :  A에서 초기화 하지 않은 변수를 B로 주면 B에서 해당 값 입력해서 A로 줌. A는 그 값 사용.
  3. ref : 매개변수를 수정해서 리턴. 원래 값에 영향을 줄 수 있음.

## return와 out의 차이는?
  1. return : 메서드 실행 결과 값 전달, 그 값 저장 여부, 사용 여부는 자유
  2. out : 매개변수로 주고, 반드시 받고 저장해서 사용해야 함.

## 다중상속을 사용하지 않는 이유
  1. 다이아몬드 문제(A를 B, C가 상속받고 D가 B,C를 상속받을 경우, 어떤 클래스가 상속받는 A를 사용하는지 모호)
  2. 설계(관계)의 복잡성 : 단일 상속보다 관계가 복잡해져 유지보수성 저하
  3. 이름 충돌 : 상속받는 이름 충돌의 가능성

## 인터페이스 사용 이유
  1. 재사용
  2. 다중상속
  3. 느슨한 결합

## 인터페이스 특징
  1. 클래스가 구현해야 하는 멤버들 정의.
  2. 클래스보다 해당 클래스의 제약조건에 가까움
  3. 인터페이스 상속 시 모든 인터페이스 멤버 구현

## 인터페이스 vs 추상클래스
  1. 인터페이스는 어떤 구현도 없음, 추상클래스는 일부 구현
  2. 인터페이스는 다중 상속 가능, 추상클래스는 단일 상속

## 열거형
  1. 연관된 상수(정수형만)를 관련 있는 이름으로 명명
  2. enum Enum {사용할 각각의 명칭}
  3. 기본 값 지정 가능. 초기화하지 않을 경우 이전 값 + 1
  4. 명시적 형변환으로 int형과 형변환 가능

## 예외처리
  1. 예외 : 프로그램 실행 중 발생하는 예기치 않은 상황(= 오류).
  2. 예외처리를 통해 프로그램이 계속 실행되도록 하며 어떤 상황에서 예외가 발생하는지도 추적 가능
  3. try { 예외 발생 가능 코드 } catch { 예외 발생 시 실행 코드 } (finally, 생략가능) { 예외발생과 상관없이 실행되는 코드 }
  4. 다중 catch문 가능.(다른 예외 상황에 따른 처리), catch문에서 예외 객체로 예외 정보 접근 가능.

## 값형
  1. struct, 일반적인 변수들
  2. 변수에 값을 직접 저장하고, 할당 or 전달 시 값 복사해서 전달. 
  3. 변수1 복사해서 변수2 생성 후 변수2 값 변화시켜도 변수1 값은 그대로.

## 참조형
  1. class
  2. 값이 담긴 주소(=참조)를 저장, 사용. 동일한 값을 가리키는 주소만 다름.
  3. 객체1 복사해서 객체2 생성 후 객체2 값 변화하면 객체1도 변화.

## 박싱과 언박싱
  1. 박싱 : 값형 --> 참조형 변환.
  2. 언박싱 : 참조형 --> 값형 변환.
  3. 박싱 시 값형은 그대로 존재하고 새로 박싱된 객체 생성 --> 메모리 관리 주의.
  4. 박싱된 객체를 참조하고 있지 않을 때 메모리에서 해제될 수 있음
  5. 박싱된 객체와 원래의 값형은 서로 독립적.

## 델리게이트
  1. 메서드를 참조하는 타입. 메서드를 변수에 저장할 수 있다.
  2. 접근이 불편한 상황일 때 주로 사용.
 
## 람다
  1. 익명(이름이 없는) 메소드.
  2. 델리게이트와 함께 사용하여 재실행성 높이고 코드 중복 제거.

## Func과 Action
  1. Func : 반환값이 있는 델리게이트(Func<int, string>은 int 값을 받아 string 반환)
  2. Action : 반환값이 없는 델리게이트.(Action<int, string>은 int와 string값 받고 void)

## LINQ
  1. 코드에서 쿼리 확장문.
  2. 데이서 소스(컬렉션, db, XML문서 등)에 데이터 필터링, 정렬, 그룹화 등 다양한 작업 수행 가능.
  3. from in where select

## Nullable
  1. 값형 변수가 Null 지정할 수 있는 방법 제공, Null인지 아닌지 확인하고 처리할 때 사용.
  2. nullalbe 변수 뒤 .HasValue 로 Null값 검사.
  3. nullable 변수 ?? default값 = 변수가 null이면 default값, 아니면 해당 변수값 사용.

## StringBuilder()
  1. 문자열들을 내부 버퍼에 넣어뒀다가 필요 시 사용.
  2. 문자열 Append(), Insert(), Replace(), Remove() 기능 제공.
  3. 문자열 반복 조작 시 메모리 할당 및 오버헤드가 크게 감소.
